#!/usr/bin/perl

use Modern::Perl 2011;

use HTTP::Proxy;
use HTTP::Proxy::BodyFilter::complete;
use HTTP::Proxy::BodyFilter::simple;
use XML::FeedPP;
use Config::IniHash;

use File::Basename;
use File::Path;

# Config

my @config_file_locations = (qw(/etc/sfp/sfp.conf /etc/sfp.conf),
                             "$ENV{HOME}/.config/sfp/sfp.conf",
                             "$ENV{HOME}/.sfp.conf");
my @cache_paths = ("/var/cache/sfp", "$ENV{HOME}/.cache/sfp");
my $meta_suffix = ".meta";

my %Config = (
    interval => 123, # in minutes, a little bit more than 2 hours
    blacklist => [],
    proxy => {
        port => 0xFEED,
    },
    mimetypes => [qw[ application/atom+xml
                      application/rdf+xml
                      application/rss+xml
                      application/xml
                      text/xml ]],
);

# Init

foreach my $config_file (@config_file_locations) {
    if (-r $config_file) {
        # Merge config from file into default config
        %Config = (%Config, %{ReadINI($config_file)});
        # Only handle first file found
        last;
    }
}

# Check if there's a different cache path set in the config
if (defined $Config{cache_path}) {
    @cache_paths = ($Config{cache_path});
}

my $cache_path;
foreach my $potential_cache_path (@cache_paths) {
    my $parent = dirname($potential_cache_path);
    my $pparent = dirname($parent);
    given ($potential_cache_path) {
        when (-d and -w _) {
            $cache_path = $_;
            last; }
        when (-d $parent and -w _)  {
            create_cache_path($cache_path = $_, $parent);
            last; }
        when (-d $pparent and -w _) {
            create_cache_path($cache_path = $_, $pparent);
            last; }
    }
}

die "Couldn't create any of the potential cache directory locations: ".
    join(", ", @cache_paths) unless $cache_path;

# Remove trailing slash from cache_path
$cache_path =~ s(/$)();

# Start the proxy daemon
my $proxy = HTTP::Proxy->new(
    port => $Config{proxy}{port},
);

# Install the filters
my $filter = HTTP::Proxy::BodyFilter::simple->new(
    sub {
        my ( $self, $dataref, $message, $protocol, $buffer ) = @_;
        # Only act if data is complete
        return unless $$dataref ne '';
        $$dataref = handle_request($message->base->as_string, $$dataref);
    },
);


foreach my $mime_type (@{$Config{mimetypes}}) {
    $proxy->push_filter(
        method => 'GET',
        mime => $mime_type,
        response => HTTP::Proxy::BodyFilter::complete->new,
        response => $filter,
    );
}

# Main loop
$proxy->start;

sub handle_request {
    my ($url, $contents) = @_;

    my $cache = url_to_file($url);
    my $feed = XML::FeedPP->new($contents, '-type' => 'string');

    if (-e $cache) {
        $feed->merge($cache);
    }
    $feed->to_file($cache);

    #TODO Filter: $feed->remove_item('');

    return $feed->to_string();
}

sub url_to_file {
    my $url = shift;
    $url =~ s(/)(_)g;
    return "$cache_path/$url";
}

sub create_cache_path {
    my ($cache_path, $parent) = @_;
    my @dirs = mkpath($cache_path);
    die "Couldn't create $cache_path despite $parent seems to be a writable directory: $!"
        unless @dirs;
}
